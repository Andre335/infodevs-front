{"ast":null,"code":"// Based on https://github.com/shramov/leaflet-plugins\n// GridLayer like https://avinmathew.com/leaflet-and-google-maps/ , but using MutationObserver instead of jQuery\n// ðŸ‚class GridLayer.GoogleMutant\n// ðŸ‚extends GridLayer\nL.GridLayer.GoogleMutant = L.GridLayer.extend({\n  options: {\n    minZoom: 0,\n    maxZoom: 23,\n    tileSize: 256,\n    subdomains: 'abc',\n    errorTileUrl: '',\n    attribution: '',\n    // The mutant container will add its own attribution anyways.\n    opacity: 1,\n    continuousWorld: false,\n    noWrap: false,\n    // ðŸ‚option type: String = 'roadmap'\n    // Google's map type. Valid values are 'roadmap', 'satellite' or 'terrain'. 'hybrid' is not really supported.\n    type: 'roadmap',\n    maxNativeZoom: 21\n  },\n  initialize: function initialize(options) {\n    L.GridLayer.prototype.initialize.call(this, options);\n    this._ready = !!window.google && !!window.google.maps && !!window.google.maps.Map;\n    this._GAPIPromise = this._ready ? Promise.resolve(window.google) : new Promise(function (resolve, reject) {\n      var checkCounter = 0;\n      var intervalId = null;\n      intervalId = setInterval(function () {\n        if (checkCounter >= 10) {\n          clearInterval(intervalId);\n          return reject(new Error('window.google not found after 10 attempts'));\n        }\n\n        if (!!window.google && !!window.google.maps && !!window.google.maps.Map) {\n          clearInterval(intervalId);\n          return resolve(window.google);\n        }\n\n        checkCounter++;\n      }, 500);\n    }); // Couple data structures indexed by tile key\n\n    this._tileCallbacks = {}; // Callbacks for promises for tiles that are expected\n\n    this._freshTiles = {}; // Tiles from the mutant which haven't been requested yet\n\n    this._imagesPerTile = this.options.type === 'hybrid' ? 2 : 1;\n  },\n  onAdd: function onAdd(map) {\n    L.GridLayer.prototype.onAdd.call(this, map);\n\n    this._initMutantContainer();\n\n    this._GAPIPromise.then(function () {\n      this._ready = true;\n      this._map = map;\n\n      this._initMutant();\n\n      map.on('viewreset', this._reset, this);\n      map.on('move', this._update, this);\n      map.on('zoomend', this._handleZoomAnim, this);\n      map.on('resize', this._resize, this); //handle layer being added to a map for which there are no Google tiles at the given zoom\n\n      google.maps.event.addListenerOnce(this._mutant, 'idle', function () {\n        this._checkZoomLevels();\n\n        this._mutantIsReady = true;\n      }.bind(this)); //20px instead of 1em to avoid a slight overlap with google's attribution\n\n      map._controlCorners.bottomright.style.marginBottom = '20px';\n      map._controlCorners.bottomleft.style.marginBottom = '20px';\n\n      this._reset();\n\n      this._update();\n\n      if (this._subLayers) {\n        //restore previously added google layers\n        for (var layerName in this._subLayers) {\n          this._subLayers[layerName].setMap(this._mutant);\n        }\n      }\n    }.bind(this));\n  },\n  onRemove: function onRemove(map) {\n    L.GridLayer.prototype.onRemove.call(this, map);\n\n    map._container.removeChild(this._mutantContainer);\n\n    this._mutantContainer = undefined;\n    google.maps.event.clearListeners(map, 'idle');\n    google.maps.event.clearListeners(this._mutant, 'idle');\n    map.off('viewreset', this._reset, this);\n    map.off('move', this._update, this);\n    map.off('zoomend', this._handleZoomAnim, this);\n    map.off('resize', this._resize, this);\n\n    if (map._controlCorners) {\n      map._controlCorners.bottomright.style.marginBottom = '0em';\n      map._controlCorners.bottomleft.style.marginBottom = '0em';\n    }\n  },\n  getAttribution: function getAttribution() {\n    return this.options.attribution;\n  },\n  setOpacity: function setOpacity(opacity) {\n    this.options.opacity = opacity;\n\n    if (opacity < 1) {\n      L.DomUtil.setOpacity(this._mutantContainer, opacity);\n    }\n  },\n  setElementSize: function setElementSize(e, size) {\n    e.style.width = size.x + 'px';\n    e.style.height = size.y + 'px';\n  },\n  addGoogleLayer: function addGoogleLayer(googleLayerName, options) {\n    if (!this._subLayers) this._subLayers = {};\n    return this._GAPIPromise.then(function () {\n      var Constructor = google.maps[googleLayerName];\n      var googleLayer = new Constructor(options);\n      googleLayer.setMap(this._mutant);\n      this._subLayers[googleLayerName] = googleLayer;\n      return googleLayer;\n    }.bind(this));\n  },\n  removeGoogleLayer: function removeGoogleLayer(googleLayerName) {\n    var googleLayer = this._subLayers && this._subLayers[googleLayerName];\n    if (!googleLayer) return;\n    googleLayer.setMap(null);\n    delete this._subLayers[googleLayerName];\n  },\n  _initMutantContainer: function _initMutantContainer() {\n    if (!this._mutantContainer) {\n      this._mutantContainer = L.DomUtil.create('div', 'leaflet-google-mutant leaflet-top leaflet-left');\n      this._mutantContainer.id = '_MutantContainer_' + L.Util.stamp(this._mutantContainer);\n      this._mutantContainer.style.zIndex = '800'; //leaflet map pane at 400, controls at 1000\n\n      this._mutantContainer.style.pointerEvents = 'none';\n\n      this._map.getContainer().appendChild(this._mutantContainer);\n    }\n\n    this.setOpacity(this.options.opacity);\n    this.setElementSize(this._mutantContainer, this._map.getSize());\n\n    this._attachObserver(this._mutantContainer);\n  },\n  _initMutant: function _initMutant() {\n    if (!this._ready || !this._mutantContainer) return;\n    this._mutantCenter = new google.maps.LatLng(0, 0);\n    var map = new google.maps.Map(this._mutantContainer, {\n      center: this._mutantCenter,\n      zoom: 0,\n      tilt: 0,\n      mapTypeId: this.options.type,\n      disableDefaultUI: true,\n      keyboardShortcuts: false,\n      draggable: false,\n      disableDoubleClickZoom: true,\n      scrollwheel: false,\n      streetViewControl: false,\n      styles: this.options.styles || {},\n      backgroundColor: 'transparent'\n    });\n    this._mutant = map;\n    google.maps.event.addListenerOnce(map, 'idle', function () {\n      var nodes = this._mutantContainer.querySelectorAll('a');\n\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].style.pointerEvents = 'auto';\n      }\n    }.bind(this)); // ðŸ‚event spawned\n    // Fired when the mutant has been created.\n\n    this.fire('spawned', {\n      mapObject: map\n    });\n  },\n  _attachObserver: function _attachObserver(node) {\n    // \t\tconsole.log('Gonna observe', node);\n    var observer = new MutationObserver(this._onMutations.bind(this)); // pass in the target node, as well as the observer options\n\n    observer.observe(node, {\n      childList: true,\n      subtree: true\n    });\n  },\n  _onMutations: function _onMutations(mutations) {\n    for (var i = 0; i < mutations.length; ++i) {\n      var mutation = mutations[i];\n\n      for (var j = 0; j < mutation.addedNodes.length; ++j) {\n        var node = mutation.addedNodes[j];\n\n        if (node instanceof HTMLImageElement) {\n          this._onMutatedImage(node);\n        } else if (node instanceof HTMLElement) {\n          Array.prototype.forEach.call(node.querySelectorAll('img'), this._onMutatedImage.bind(this));\n        }\n      }\n    }\n  },\n  // Only images which 'src' attrib match this will be considered for moving around.\n  // Looks like some kind of string-based protobuf, maybe??\n  // Only the roads (and terrain, and vector-based stuff) match this pattern\n  _roadRegexp: /!1i(\\d+)!2i(\\d+)!3i(\\d+)!/,\n  // On the other hand, raster imagery matches this other pattern\n  _satRegexp: /x=(\\d+)&y=(\\d+)&z=(\\d+)/,\n  // On small viewports, when zooming in/out, a static image is requested\n  // This will not be moved around, just removed from the DOM.\n  _staticRegExp: /StaticMapService\\.GetMapImage/,\n  _onMutatedImage: function _onMutatedImage(imgNode) {\n    // \t\tif (imgNode.src) {\n    // \t\t\tconsole.log('caught mutated image: ', imgNode.src);\n    // \t\t}\n    var coords;\n    var match = imgNode.src.match(this._roadRegexp);\n    var sublayer = 0;\n\n    if (match) {\n      coords = {\n        z: match[1],\n        x: match[2],\n        y: match[3]\n      };\n\n      if (this._imagesPerTile > 1) {\n        imgNode.style.zIndex = 1;\n        sublayer = 1;\n      }\n    } else {\n      match = imgNode.src.match(this._satRegexp);\n\n      if (match) {\n        coords = {\n          x: match[1],\n          y: match[2],\n          z: match[3]\n        };\n      } // \t\t\timgNode.style.zIndex = 0;\n\n\n      sublayer = 0;\n    }\n\n    if (coords) {\n      var tileKey = this._tileCoordsToKey(coords);\n\n      imgNode.style.position = 'absolute';\n      imgNode.style.visibility = 'hidden';\n      var key = tileKey + '/' + sublayer; // console.log('mutation for tile', key)\n      //store img so it can also be used in subsequent tile requests\n\n      this._freshTiles[key] = imgNode;\n\n      if (key in this._tileCallbacks && this._tileCallbacks[key]) {\n        // console.log('Fullfilling callback ', key);\n        //fullfill most recent tileCallback because there maybe callbacks that will never get a \n        //corresponding mutation (because map moved to quickly...)\n        this._tileCallbacks[key].pop()(imgNode);\n\n        if (!this._tileCallbacks[key].length) {\n          delete this._tileCallbacks[key];\n        }\n      } else {\n        if (this._tiles[tileKey]) {\n          //we already have a tile in this position (mutation is probably a google layer being added)\n          //replace it\n          var c = this._tiles[tileKey].el;\n          var oldImg = sublayer === 0 ? c.firstChild : c.firstChild.nextSibling;\n\n          var cloneImgNode = this._clone(imgNode);\n\n          c.replaceChild(cloneImgNode, oldImg);\n        }\n      }\n    } else if (imgNode.src.match(this._staticRegExp)) {\n      imgNode.style.visibility = 'hidden';\n    }\n  },\n  createTile: function createTile(coords, done) {\n    var key = this._tileCoordsToKey(coords);\n\n    var tileContainer = L.DomUtil.create('div');\n    tileContainer.dataset.pending = this._imagesPerTile;\n    done = done.bind(this, null, tileContainer);\n\n    for (var i = 0; i < this._imagesPerTile; i++) {\n      var key2 = key + '/' + i;\n\n      if (key2 in this._freshTiles) {\n        var imgNode = this._freshTiles[key2];\n        tileContainer.appendChild(this._clone(imgNode));\n        tileContainer.dataset.pending--; // \t\t\t\tconsole.log('Got ', key2, ' from _freshTiles');\n      } else {\n        this._tileCallbacks[key2] = this._tileCallbacks[key2] || [];\n\n        this._tileCallbacks[key2].push(function (c\n        /*, k2*/\n        ) {\n          return function (imgNode) {\n            c.appendChild(this._clone(imgNode));\n            c.dataset.pending--;\n\n            if (!parseInt(c.dataset.pending)) {\n              done();\n            } // \t\t\t\t\t\tconsole.log('Sent ', k2, ' to _tileCallbacks, still ', c.dataset.pending, ' images to go');\n\n          }.bind(this);\n        }.bind(this)(tileContainer\n        /*, key2*/\n        ));\n      }\n    }\n\n    if (!parseInt(tileContainer.dataset.pending)) {\n      L.Util.requestAnimFrame(done);\n    }\n\n    return tileContainer;\n  },\n  _clone: function _clone(imgNode) {\n    var clonedImgNode = imgNode.cloneNode(true);\n    clonedImgNode.style.visibility = 'visible';\n    return clonedImgNode;\n  },\n  _checkZoomLevels: function _checkZoomLevels() {\n    //setting the zoom level on the Google map may result in a different zoom level than the one requested\n    //(it won't go beyond the level for which they have data).\n    var zoomLevel = this._map.getZoom();\n\n    var gMapZoomLevel = this._mutant.getZoom();\n\n    if (!zoomLevel || !gMapZoomLevel) return;\n\n    if (gMapZoomLevel !== zoomLevel || //zoom levels are out of sync, Google doesn't have data\n    gMapZoomLevel > this.options.maxNativeZoom) {\n      //at current location, Google does have data (contrary to maxNativeZoom)\n      //Update maxNativeZoom\n      this._setMaxNativeZoom(gMapZoomLevel);\n    }\n  },\n  _setMaxNativeZoom: function _setMaxNativeZoom(zoomLevel) {\n    if (zoomLevel != this.options.maxNativeZoom) {\n      this.options.maxNativeZoom = zoomLevel;\n\n      this._resetView();\n    }\n  },\n  _reset: function _reset() {\n    this._initContainer();\n  },\n  _update: function _update() {\n    // zoom level check needs to happen before super's implementation (tile addition/creation)\n    // otherwise tiles may be missed if maxNativeZoom is not yet correctly determined\n    if (this._mutant) {\n      var center = this._map.getCenter();\n\n      var _center = new google.maps.LatLng(center.lat, center.lng);\n\n      this._mutant.setCenter(_center);\n\n      var zoom = this._map.getZoom();\n\n      var fractionalLevel = zoom !== Math.round(zoom);\n\n      var mutantZoom = this._mutant.getZoom(); //ignore fractional zoom levels\n\n\n      if (!fractionalLevel && zoom != mutantZoom) {\n        this._mutant.setZoom(zoom);\n\n        if (this._mutantIsReady) this._checkZoomLevels(); //else zoom level check will be done later by 'idle' handler\n      }\n    }\n\n    L.GridLayer.prototype._update.call(this);\n  },\n  _resize: function _resize() {\n    var size = this._map.getSize();\n\n    if (this._mutantContainer.style.width === size.x && this._mutantContainer.style.height === size.y) return;\n    this.setElementSize(this._mutantContainer, size);\n    if (!this._mutant) return;\n    google.maps.event.trigger(this._mutant, 'resize');\n  },\n  _handleZoomAnim: function _handleZoomAnim() {\n    if (!this._mutant) return;\n\n    var center = this._map.getCenter();\n\n    var _center = new google.maps.LatLng(center.lat, center.lng);\n\n    this._mutant.setCenter(_center);\n\n    this._mutant.setZoom(Math.round(this._map.getZoom()));\n  },\n  // Agressively prune _freshtiles when a tile with the same key is removed,\n  // this prevents a problem where Leaflet keeps a loaded tile longer than\n  // GMaps, so that GMaps makes two requests but Leaflet only consumes one,\n  // polluting _freshTiles with stale data.\n  _removeTile: function _removeTile(key) {\n    if (!this._mutant) return; //give time for animations to finish before checking it tile should be pruned\n\n    setTimeout(this._pruneTile.bind(this, key), 1000);\n    return L.GridLayer.prototype._removeTile.call(this, key);\n  },\n  _pruneTile: function _pruneTile(key) {\n    var gZoom = this._mutant.getZoom();\n\n    var tileZoom = key.split(':')[2];\n\n    var googleBounds = this._mutant.getBounds();\n\n    var sw = googleBounds.getSouthWest();\n    var ne = googleBounds.getNorthEast();\n    var gMapBounds = L.latLngBounds([[sw.lat(), sw.lng()], [ne.lat(), ne.lng()]]);\n\n    for (var i = 0; i < this._imagesPerTile; i++) {\n      var key2 = key + '/' + i;\n\n      if (key2 in this._freshTiles) {\n        var tileBounds = this._map && this._keyToBounds(key);\n\n        var stillVisible = this._map && tileBounds.overlaps(gMapBounds) && tileZoom == gZoom;\n        if (!stillVisible) delete this._freshTiles[key2]; //\t\t\t\tconsole.log('Prunning of ', key, (!stillVisible))\n      }\n    }\n  }\n}); // ðŸ‚factory gridLayer.googleMutant(options)\n// Returns a new `GridLayer.GoogleMutant` given its options\n\nL.gridLayer.googleMutant = function (options) {\n  return new L.GridLayer.GoogleMutant(options);\n};","map":null,"metadata":{},"sourceType":"script"}